#!/usr/bin/python
import sys
import os
import commands
import httplib
import json
import time
from urlparse import urlparse

def exit_with(msg):
    """ Exit with a non-zero status and print a message to stdout """
    print(msg)
    exit(1)

color_codes = {
    "black": 0, "red": 1, "green": 2, "yellow": 3, "blue": 4, "magenta": 5, "cyan": 6, "white": 7
}

def color_code(foreground, background):
    """ generate the ansi color code for a given fg/bg pair """
    if foreground in color_codes:
        bg = 0
        fg = color_codes[foreground]
        if background in color_codes:
            bg = color_codes[background]
        return str(30 + fg) + ";" + str(40 + bg) + "m"
    else:
        exit_with("Please provide a foreground color.")

def colorize(msg, fg, bg=None):
    """ wrap the provided message in the ansi escape and reset codes for the provided colors """
    CONTROL = "\x1B["
    RESET = CONTROL + "0m"
    return CONTROL + color_code(fg, bg) + msg + RESET

def colerr(msg):
    """ return an error-styled message """
    return colorize(msg, "black", "red")

def request(url, method):
    """ use httplib to connect to a url for a given method """
    (host, path) = urlparse(url)[1:3]
    if host and path:
        try:
            client = httplib.HTTPConnection(host)
            client.request(method, path)
            return client.getresponse().read()
        except Exception, e:
            print(colerr(str(e)))
            exit_with("Couldn't %s to %s" % (method, url))
    else:
        exit_with("I wasn't able to parse: " + colorize(url, "red") + "\n" +
                  "Be sure to use the format: " + colorize("scheme://hostname/conduit", "green") +
                  "\n\n" +
                  "parsed host: %s\n" % host +
                  "parsed repo: %s" % path)

def get(url):
    return request(url, "GET")

def post(url):
    return request(url, "POST")

def get_push_info(target):
    """ find the temporary push and poll endpoints generated by scm conduit """
    response = post(target)
    try:
        return json.loads(response)
    except Exception, e:
        exit_with(colerr(str(e) + " from %s" % target))

    return json.loads(response)

def find_scm():
    """ Try to find out whether we are in a git or bazaar directory """
    if os.path.exists(".git"):
        return "git"
    elif os.path.exists(".bzr"):
        return "bz"
    else:
        raise Exception("This doesn't appear to be a directory that is tracked by git or bzr")

if __name__ == "__main__":
    scm = find_scm()
    repo = None

    if len(sys.argv) < 2:
        if scm == "git":
            origin = commands.getoutput("""git remote -v | awk '{ if ($1 == \"origin" && $3 == "(push)") print $2}'""")
            if origin:
                repo = origin.replace(".git", "")
                print("Using " + colorize(repo, "green") + " as conduit endpoint")
            else:
                exit_with(colerr("Wasn't able to find an origin to push to."))
        else:
            exit_with(colerr("Please provide a push location."))
    else:
        repo = sys.argv[1]

    (scheme, host) = urlparse(repo)[0:2]

    user = None
    if len(sys.argv) > 2:
        user = sys.argv[2]

    #Get temporary information from server
    print("Attempting to contact remote server for information...")
    info = get_push_info(repo)
    temp_push = info.get("pushLocation")
    temp_result = info.get("resultLocation")

    #Handle malformed response from server
    err = ""
    if not temp_push:
        err += "\n" + colerr("Wasn't able to find a temporary push endpoint")
    if not temp_result:
        err += "\n" + colerr("Wasn't able to find a temporary result endpoint")
    if err:
        exit_with(err)

    if user:
        temp_push = temp_push.replace("sftp://", "sftp://%s@" % user)
        temp_push = temp_push.replace("ssh://", "ssh://%s@" % user)

    print("Pushing to " + temp_push)
    cmd = "%s push %s" % (scm, temp_push)
    os.system(cmd)

    while True:
        status = get(scheme + "://" + host + temp_result)
        if status.startswith("WORKING"):
            sys.stdout.write(".")
            sys.stdout.flush()
            time.sleep(0.25)
        else:
            if scm == "git":
                os.system("get fetch --tags")
                print(status + "\n")
                exit_with("DONE")
